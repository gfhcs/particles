Optimization: Es soll zwei Tasks geben:
    1. Der Simulation-Task zieht einen State nach dem andern aus der Simulation und hängt sie an eine BlockingQueue an. Deren Kapazität sollte man sinnvoll begrenzen.
    2. Der Render-Task zieht so lange States aus der BlockingQueue, bis der Simulation-Task terminiert und die BlockingQueue leer ist. Er rendert das VideoCodec
Optimization: Der Renderer könnte das Bild in 1 Abschnitt pro Prozessor aufspalten. Dann rendert jeder Prozessor einen Abschnitt und zum Schluss werden die Abschnitte aneinander gefügt. Zum Beispiel könnte man die Z-Achse in Abschnitte unterteilen
    --> Ich will, dass das Rendering deutlich schneller geht, als das Simulieren
Optimization: Parallelisieren mit Tasks!
Optimization: Barnes-Hut!
Optimization: Embedded Runge-Kutta
Optimization: Separate step sizes for each particle
Implement symplectic integrators and create test cases for them. See English Wikipedia page.
Renderer-Klassen einführen. Für Renderer braucht man Cameras. Achtung: Auch Renderer werden mal mit Tasks arbeiten müssen!
    --> Eine Camera mappt States auf Frames. Ein Renderer bekommt eine Sequenz von States und produziert daraus ein Video.
    --> Außerdem sollte es so etwas wie einen State-Buffer geben, damit die Simulation schon weitere Schritte berechnen kann, während der Renderer noch rendert. 
    --> Und ich will in der Lage sein, State-Sequenzen auf die Platte zu serialisieren!
Artwork: Background images, colors, stats, sound (music, noise, collisions)
Partikel abstrahieren: Man will mit Arrays von Partikeln arbeiten, die sich mit Eigenschaften und Kräften erweitern lassen!
    --> Ich glaube, eine gute Idee wäre es, eine abstrakte Klasse ParticleCloud einzuführen. Erben können dieser dann Arrays hinzufügen. Das ginge z.B. mit Property-Objekten (Farbe, Ladung, Masse, ...) und Force-Objekten (Gravity, Coulomb, ...)
How about chain reactions, e.g. nuclear fission. That would be a lot of fun!
How about billards?
Chemical reactions?
Volcanic eruption?
Tsunami?
Am liebsten würde ich jetzt dafür sorgen, dass Tasks auch übers Netzwerk verteilt werden...
Und dann würde man Tasks auch gerne noch auf die GPU auslagern.
 
