Prüfen: Geht die Zeit vor allem für's simulieren, oder vor allem für's Rendern drauf?
    --> Falls es das Rendern ist, sollten wir das wohl zuerst optimieren...
Optimization: Die Beschleunigung, die A durch B erfährt, ist genau das Inverse der Beschleunigung, die B durch A erfährt, d.h. mit Caching können wir uns die Hälfte der Berechnungen sparen.
Optimization: Parallelisieren mit Tasks!
Optimization: Barnes-Hut!
Optimization: Embedded Runge-Kutta
Optimization: Separate step sizes for each particle
Implement symplectic integrators and create test cases for them. See English Wikipedia page.
Renderer-Klassen einführen. Für Renderer braucht man Cameras. Achtung: Auch Renderer werden mal mit Tasks arbeiten müssen!
    --> Eine Camera mappt States auf Frames. Ein Renderer bekommt eine Sequenz von States und produziert daraus ein Video.
    --> Außerdem sollte es so etwas wie einen State-Buffer geben, damit die Simulation schon weitere Schritte berechnen kann, während der Renderer noch rendert. 
    --> Und ich will in der Lage sein, State-Sequenzen auf die Platte zu serialisieren!
Artwork: Background images, colors, stats, sound (music, noise, collisions)
Partikel abstrahieren: Man will mit Arrays von Partikeln arbeiten, die sich mit Eigenschaften und Kräften erweitern lassen!
    --> Ich glaube, eine gute Idee wäre es, eine abstrakte Klasse ParticleCloud einzuführen. Erben können dieser dann Arrays hinzufügen. Das ginge z.B. mit Property-Objekten (Farbe, Ladung, Masse, ...) und Force-Objekten (Gravity, Coulomb, ...)
How about chain reactions, e.g. nuclear fission. That would be a lot of fun!
How about billards?
Chemical reactions?
Volcanic eruption?
Tsunami?
Am liebsten würde ich jetzt dafür sorgen, dass Tasks auch übers Netzwerk verteilt werden...
Und dann würde man Tasks auch gerne noch auf die GPU auslagern.
 
